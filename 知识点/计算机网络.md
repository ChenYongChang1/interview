计算机网络
===
参考：
* [前端必备HTTP技能之HTTP请求头响应头中常用字段详解](http://www.jianshu.com/p/6e86903d74f7)
* [《网络是怎样连接的》读书笔记](http://www.shymean.com/article/%E3%80%8A%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0)

## 问题
* url从地址栏输入到展示整个页面发生了什么
* 状态码
* 缓存控制
* Token及JSON Web Token认证原理
* Cookie、Session、LocalStorage和SessionStorage的作用及差异
* https
* HTTP2

## HTTP
### 常见的通用头
* __`Cache-Control`设置请求响应链上所有的缓存机制必须遵守的指令__
* `Date`用来说明构建报文的时间和日期

## 常见的请求头
### Accept头部
* `Accept`设置接受的内容类型
* `Accept-Charset` 设置接受的字符编码
* `Accept-Encoding`设置接受的编码格式
* `Accept-Datetime`设置接受的版本时间
* `Accept-Language`设置接受的语言

### 请求实体首部行
* `Content-Type`设置请求体的MIME类型（适用POST和PUT请求）
* `Content-Length`设置请求体的字节长度
* `Content-MD5`设置基于MD5算法对请求体内容进行Base64二进制编码

### 资源请求头部
* `Origin`标识跨域资源请求（请求服务端设置Access-Control-Allow-Origin响应字段）
* `Range` 请求部分实体，设置请求实体的字节数范围，具体可以参见HTTP/1.1中的Byte serving

### 条件请求头部
* `if-Modified-Since` 设置更新时间，从更新时间到服务端接受请求这段时间内如果资源没有改变，允许服务端返回304 Not Modified
* `If-None-Match`设置客户端ETag，如果和服务端接受请求生成的ETage相同，允许服务端返回304 Not Modified
* `If-Match`设置客户端的ETag,当时客户端ETag和服务器生成的ETag一致才执行，适用于更新自从上次更新之后没有改变的资源
* `If-Range`设置客户端ETag，如果和服务端接受请求生成的ETage相同，返回缺失的实体部分；否则返回整个新的实体
* `If-Unmodified-Since` 设置更新时间，只有从更新时间到服务端接受请求这段时间内实体没有改变，服务端才会发送响应

### 用户识别头部
* `Cookie`设置服务器使用Set-Cookie发送的http cookie
* `Authorization`设置HTTP身份验证的凭证
* `From`设置发送请求的用户的email地址
* `Host`设置服务器域名和TCP端口号，如果使用的是服务请求标准端口号，端口号可以省略
* `Referer 设置前一个页面的地址，并且前一个页面中的连接指向当前请求，意思就是如果当前请求是在A页面中发送的，那么referer就是A页面的url地址`
* `User-Agent`用户代理的字符串值

### 常见的响应头
* `Set-Cookie`设置cookie

## 缓存
参考之前的[整理](http://www.shymean.com/article/HTTP%E5%8D%8F%E8%AE%AE%E4%B9%8B%E7%BC%93%E5%AD%98%EF%BC%88%E4%B8%89%EF%BC%89)

## TCP建立连接三次握手
TCP连接操作的大致流程如下
* 第一步是在TCP模块创建表示控制信息的头部，
    * 设置发送方和接收方的端口号和SYN比特，通过头部中发送方和接收方的端口号可以找到要连接的套接字
    * 然后客户端的TCP模块委托IP模块发送包含TCP头部的网络包，
* 服务器的TCP模块会根据这个网络包的TCP头部信息找到需要连接的服务器套接字信息，并写入相关信息，修改为正在连接状态然后服务器的TCP模块会返回响应
    * 这个过程与客户端一样，创建控制信息的头部。
    * 此外在返回响应时还需要将ACK控制位设置为1，表示通信确认。
    * 然后服务器的TCP模块委托其IP模块发送响应数据包
* 客户端的TCP模块通过响应数据包的TCP头部信息确认连接服务器的操作是否成功，如果SYN为1则表示成功，此时会向客户端的套接字中写入服务器的IP地址、端口号等信息
* 后，客户端需要将ACK比特设置为1然后发回服务器，告知服务器刚才的响应包已经收到

可以看见，上面一共进行了三次数据包的发送（客户端两次，服务器一次），因此被称为三次握手。

## TCP建立连接四次挥手
在数据收发完成以后，就可以选择断开连接了。完成数据的发送的一方会断开过程，这里以服务器举例：
* 首先，服务器协议栈会生成包含断开信息的TCP头部（即将FIN比特设为1），接着委托IP模块发送，同时，服务器的套接字会记录断开操作的相关信息
* 户端协议栈收到FIN为1的TCP头部时，会将客户端自己的套接字标记为进入断开的状态，同时向服务器发送一个ACK号表示确认收到服务器的断开操作
* 了一会应用程序读取了全部的数据之后，客户端协议栈也会与服务器协议栈一样，生成一个包含断开信息FIN为1的包，委托IP模块发送给服务器
* 务器最后会返回包含ACK号的确认包，最后会删除对应的套接字

可以看见断开连接一共需要发送4个数据包（服务器两个，客户端两个），因此被称为四次挥手。

## 路由器的中转规则
路由器的端口是以实际的发送方和接收方来收发网络包的，因此路由器的每个端口都具有MAC地址和IP地址，只接受与自身地址匹配的包。

路由器根据IP地址表来判断转发目标，实际上这里的IP地址只包含表示子网的网络号部分的比特值（这里就体现了子网掩码的作用，即表示在匹配网络包目标地址时需要对比的比特数量），而表示主机号部分的比特值全部为0（这与交换机不同，交换机会匹配完整的MAC地址），这样就可以将多条某个子网的IP导向同一个端口。

有时候可能会匹配多条子网记录，此时路由器会寻找网络号比特位最长的（网络号越长，说明主机号越短，子网内可分配的主机越少，可以缩小目标范围），如果网络号比特位相等，则匹配跃点数最小的记录。

有时地址本身的子网掩码和路由表 中的子网掩码是不一致的，这是路由聚合的结果。路由聚合会将几个子 网合并成一个子网，并在路由表中只产生一条记录。经过路由聚合，多个子网会被合并成一个子网，子网掩码会发生 变化，同时，目标地址列也会改成聚合后的地址。

## 服务器响应
一般的做法是每有一个客户端连接进来，就fork一个新的服务器程序
* 服务器程序包含两个模块，等待连接模块和负责与客户端通信的模块
* 服务器启动后完成初始化操作，运行等待模块，创建套接字，等待客户端的连接
* 接收到客户端连接时，等待模块会恢复运行并接收连接，然后启动服务器的客户端通信模块，并移交完成连接的套接字
* 每次有新的客户端发起连接，都会启动一个新的客户端通信模块（这个过程需要消耗服务器性能），因此通信模块与客户端是一对一的关系

## 本地起了一个http server，为什么只能在同一个WIFI(局域网)上访问？
你没有公网IP当然就不能被外网访问了。常见的WIFI情况下，一般的ip会是~192.168.0.x·这样的，只是对局域网(同WIFI下)可见，并没有部署到公开外网，因此外网是访问不了的。