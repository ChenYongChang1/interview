JavaScript模块
===

问题：JavaScript有哪些模块规范？他们的区别是什么？

参考之前的整理:[JavaScript模块管理机制](http://www.shymean.com/article/JavaScript%E6%A8%A1%E5%9D%97%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6)
<!-- TOC -->

- [服务端CommonJS模块规范](#服务端commonjs模块规范)
- [浏览器端AMD与CMD规范](#浏览器端amd与cmd规范)
    - [AMD模块规范](#amd模块规范)
    - [CMD](#cmd)
    - [CMD与AMD的区别](#cmd与amd的区别)
- [ES6模块机制](#es6模块机制)
    - [ES6模块和CommonJS模块的区别](#es6模块和commonjs模块的区别)

<!-- /TOC -->

## 服务端CommonJS模块规范
使用`module.exports`、`exports`导出模块，使用`require`引入模块。

NodeJS采用的是CommonJS规范，`CommonJS`的一个模块就是一个脚本文件。require命令第一次加载该脚本时就会执行整个脚本，然后在内存中生成一个对象。

这里需要注意的是理解module.exports和exports的区别

```js
exports.test = function(){}
module.exports.test2 = function(){}

// 当重新为module.exports赋值后，exports导出的数据都会丢失
module.exports = {}
```

* 整个文件导出的模块（也就是require() 的返回）是 module.exports
* module.exports和exports在初始时指向同一个对象，因此可以使用exports向模块对象上增加属性和方法
* module.exports如果指向了另外一个对象，则exports的修改全部无效了（因为最后导出的是module.exports）

另外一个问题是`require`加载包的顺序规则，在NodeJS内部有个很复杂实现，这里就不展开了，感兴趣可以移步这里：[require() 源码解读](http://www.ruanyifeng.com/blog/2015/05/require.html)

## 浏览器端AMD与CMD规范
CommonJS是同步加载的，加载模块时会阻塞后续代码的执行，这对于Node讲问题不大，但是对于浏览器而言网络传输的效率是不容忽视的，所以才有了AMD规范

下面我们来讨论一下浏览器中的模块加载机制：AMD和CMD规范。并给出简单的实现（非常抽象的实现，一些重要的特性如依赖分析、异步模块等都进行了忽略）。

### AMD模块规范
由于浏览器在解析文档时，遇见脚本会加载解析和执行，为了提高页面性能，一般的处理办法是异步延迟加载脚本，这正是AMD全称中Asynchronous的含义，在AMD中，模块将被异步加载，模块加载不影响后面语句的运行。所有依赖某些模块的语句均放置在回调函数中。

异步加载带来的问题是：在浏览器中，必须等待依赖的模块加载成功，对应的声明模块才能够执行。换句话说，AMD中的模块是依赖前置的。在AMD规范中，通过`define`定义模块，通过`require`引入模块。下面是一个极简版的AMD模块管理工具的实现
```js

;(function(window) {
    // 定义一个保存模块的闭包变量
    var modules = {};

    // define和require接口用于修改和使用modules变量
    function define(name, deps, fn) {
        for (var i = 0; i < deps.length; i++) {
            deps[i] = modules[deps[i]];
        }
        modules[name] = fn.apply(fn, deps);
    }

    function require(name) {
        fn.call(fn, modules[name]);
    }

    window.require = require;
    window.define = define;
})(window);
```
使用示例代码
```js
define("bar", [], function () {
    console.log('bar exec')
    return {
        hello() {
            console.log("hello from bar");
        }
    };
});
define("test", [], function() {
    console.log("test exec");
    return {
        hello() {
            console.log("hello from test");
        }
    };
});
define("foo", ["bar", "test"], function (bar, test) {
    bar.hello()
    test.hello()

    return {};
});
require("foo", function (foo) {});
```
上述代码依次输出
```
bar exec
test exec
hello from bar
hello from test
```
根据其实现可以看见，模块在require声明依赖时就会立即执行，并将模块结果通过依赖前置的方式传入对应所需的函数中执行。

### CMD
下面是实现的一个极简易版本的CMD模块加载工具
```js
(function (window) {
    // 定义一个保存模块的闭包变量
    var modules = {};

    // define和require接口用于修改和使用modules变量
    function define(name, fn) {
        modules[name] = {
            isExec: false,
            fn: fn,
            result: {} // 初始化exports
        };
    }

    function require(name) {
        var module = modules[name];
        if (!module.isExec) {
            module.fn.apply(null, [require, module.result]);
        }
        return module.result;
    }

    window.define = define;
    window.useModule = function(ids, fn){
        var exports = ids.map(id=>{
            return require(id);
        })
        fn && fn.apply(null, exports);
    }
})(window);
```
使用示例代码
```js
define("bar", function(require, exports) {
    console.log("bar exec");
    exports.hello = function() {
        console.log("hello from bar");
    };
});

define("test", function (require, exports) {
    console.log("test exec");
    exports.hello = function () {
        console.log("hello from test");
    }
})


define("foo", function(require, exports) {
    var bar = require("bar");
    bar.hello();

    var test = require('test');
    test.hello();
    var test = require('test');

    var test2 = require("test");
    console.log(test2 === test2)
});

useModule(["foo"])
```
上面代码依次输出
```
bar exec
hello from bar
test exec
hello from test
true // 每个模块只执行了一次
```
可以看见，只有当调用require时，模块才会运行，代码执行顺序跟调用require的顺序一致

### CMD与AMD的区别
参考:[再谈 SeaJS 与 RequireJS 的差异](https://div.io/topic/430)
* AMD 是提前执行，CMD 是延迟执行
* CMD 推崇依赖就近，AMD 推崇依赖前置

## ES6模块机制
新增`import`和`export`，参考
* [import文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import)
* [export文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/export)

export包括
* 命名导出，命名导出对导出多个值很有用。在导入期间，必须使用相应对象的相同名称。
* 默认导出，可以使用任何名称导入默认导出

注意不能使用var，let或const作为默认导出。

### ES6模块和CommonJS模块的区别
参考
* https://juejin.im/entry/5a879e28f265da4e82635152

主要有下面两个区别
* ES6 模块输出的是值的引用，输出接口动态绑定，而 CommonJS 输出的是值的拷贝
* ES6 模块编译时执行，而 CommonJS 模块总是在运行时加载

**关于第一点**
在 CommonJS 模块中，如果你 require 了一个模块，那就相当于你执行了该文件的代码并最终获取到模块输出的 module.exports 对象的一份拷贝，如果在模块文件中存在异步的数据，则需要使用函数延时执行，再次require对应模块，从而获得更新数据的拷贝
* CommonJS 模块中 require 引入模块的位置不同会对输出结果产生影响，并且会生成值的拷贝
* CommonJS 模块重复引入的模块并不会重复执行，再次获取模块只会获得之前获取到的模块的拷贝

在 ES6 模块中就不再是生成输出对象的拷贝，而是动态关联模块中的值。当模块中的值改变，会影响当前文件中的值

**关于第二点**
ES6 模块编译时执行会导致有以下两个特点：
* import 命令会被 JavaScript 引擎静态分析，优先于模块内的其他内容执行，即在文件中的任何位置引入 import 模块都会被提前到文件顶部
* export 命令会有变量声明提前的效果，通过模块循环引用可以看出其效果
