JavaScript模块
===

> 问题：JavaScript有哪些模块规范？他们的区别是什么？模块的循环依赖机制是什么？

## 服务端CommonJS模块规范
使用`module.exports`、`exports`导出模块，使用`require`引入模块。

NodeJS采用的是CommonJS规范，`CommonJS`的一个模块就是一个脚本文件。require命令第一次加载该脚本时就会执行整个脚本，然后在内存中生成一个对象。

这里需要注意的是理解module.exports和exports的区别

```js
exports.test = function(){}
module.exports.test2 = function(){}

// 当重新为module.exports赋值后，exports导出的数据都会丢失
module.exports = {}
```

* 整个文件导出的模块（也就是require() 的返回）是 module.exports
* module.exports和exports在初始时指向同一个对象，因此可以使用exports向模块对象上增加属性和方法
* module.exports如果指向了另外一个对象，则exports的修改全部无效了（因为最后导出的是module.exports）

另外一个问题是`require`加载包的顺序规则，在NodeJS内部有个很复杂实现，这里就不展开了，感兴趣可以移步这里：[require() 源码解读](http://www.ruanyifeng.com/blog/2015/05/require.html)


## 浏览器端AMD与CMD规范
CommonJS是同步加载的，加载模块时会阻塞后续代码的执行，这对于Node讲问题不大，但是对于浏览器而言网络传输的效率是不容忽视的，所以才有了AMD规范

下面我们来讨论一下浏览器中的模块加载机制：AMD和CMD规范。并给出简单的实现（非常抽象的实现，一些重要的特性如依赖分析、异步模块等都进行了忽略）。

### AMD模块规范
由于浏览器在解析文档时，遇见脚本会加载解析和执行，为了提高页面性能，一般的处理办法是异步延迟加载脚本，这正是AMD全称中Asynchronous的含义，在AMD中，模块将被异步加载，模块加载不影响后面语句的运行。所有依赖某些模块的语句均放置在回调函数中。

异步加载带来的问题是：在浏览器中，必须等待依赖的模块加载成功，对应的声明模块才能够执行。换句话说，AMD中的模块是依赖前置的。在AMD规范中，通过`define`定义模块，通过`require`引入模块。下面是一个极简版的AMD模块管理工具的实现
```js

;(function(window) {
    // 定义一个保存模块的闭包变量
    var modules = {};

    // define和require接口用于修改和使用modules变量
    function define(name, deps, fn) {
        for (var i = 0; i < deps.length; i++) {
            deps[i] = modules[deps[i]];
        }
        modules[name] = fn.apply(fn, deps);
    }

    function require(name) {
        fn.call(fn, modules[name]);
    }

    window.require = require;
    window.define = define;
})(window);
```
使用示例代码
```js
define("bar", [], function () {
    console.log('bar exec')
    return {
        hello() {
            console.log("hello from bar");
        }
    };
});
define("test", [], function() {
    console.log("test exec");
    return {
        hello() {
            console.log("hello from test");
        }
    };
});
define("foo", ["bar", "test"], function (bar, test) {
    bar.hello()
    test.hello()

    return {};
});
require("foo", function (foo) {});
```
上述代码依次输出
```
bar exec
test exec
hello from bar
hello from test
```
根据其实现可以看见，模块在require声明依赖时就会立即执行，并将模块结果通过依赖前置的方式传入对应所需的函数中执行。

### CMD
下面是实现的一个极简易版本的CMD模块加载工具
```js
(function (window) {
    // 定义一个保存模块的闭包变量
    var modules = {};

    // define和require接口用于修改和使用modules变量
    function define(name, fn) {
        modules[name] = {
            isExec: false,
            fn: fn,
            result: {} // 初始化exports
        };
    }

    function require(name) {
        var module = modules[name];
        if (!module.isExec) {
            module.fn.apply(null, [require, module.result]);
        }
        return module.result;
    }

    window.define = define;
    window.useModule = function(ids, fn){
        var exports = ids.map(id=>{
            return require(id);
        })
        fn && fn.apply(null, exports);
    }
})(window);
```
使用示例代码
```js
define("bar", function(require, exports) {
    console.log("bar exec");
    exports.hello = function() {
        console.log("hello from bar");
    };
});

define("test", function (require, exports) {
    console.log("test exec");
    exports.hello = function () {
        console.log("hello from test");
    }
})


define("foo", function(require, exports) {
    var bar = require("bar");
    bar.hello();

    var test = require('test');
    test.hello();
    var test = require('test');

    var test2 = require("test");
    console.log(test2 === test2)
});

useModule(["foo"])
```
上面代码依次输出
```
bar exec
hello from bar
test exec
hello from test
true // 每个模块只执行了一次
```
可以看见，只有当调用require时，模块才会运行，代码执行顺序跟调用require的顺序一致

### CMD与AMD的区别
参考:[再谈 SeaJS 与 RequireJS 的差异](https://div.io/topic/430)
* AMD 是提前执行，CMD 是延迟执行
* CMD 推崇依赖就近，AMD 推崇依赖前置

## ES6模块机制
新增`import`和`export`，参考
* [import文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import)
* [export文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/export)

export包括
* 命名导出，命名导出对导出多个值很有用。在导入期间，必须使用相应对象的相同名称。
* 默认导出，可以使用任何名称导入默认导出

注意不能使用var，let或const作为默认导出。

### ES6模块和CommonJS模块的区别
参考
* https://juejin.im/entry/5a879e28f265da4e82635152

主要有下面两个区别
* ES6 模块输出的是值的引用，输出接口动态绑定，而 CommonJS 输出的是值的拷贝
* ES6 模块编译时执行，而 CommonJS 模块总是在运行时加载

**关于第一点**
在 CommonJS 模块中，如果你 require 了一个模块，那就相当于你执行了该文件的代码并最终获取到模块输出的 module.exports 对象的一份拷贝，如果在模块文件中存在异步的数据，则需要使用函数延时执行，再次require对应模块，从而获得更新数据的拷贝
* CommonJS 模块中 require 引入模块的位置不同会对输出结果产生影响，并且会生成值的拷贝
* CommonJS 模块重复引入的模块并不会重复执行，再次获取模块只会获得之前获取到的模块的拷贝

在 ES6 模块中就不再是生成输出对象的拷贝，而是动态关联模块中的值。当模块中的值改变，会影响当前文件中的值

**关于第二点**
ES6 模块编译时执行会导致有以下两个特点：
* import 命令会被 JavaScript 引擎静态分析，优先于模块内的其他内容执行，即在文件中的任何位置引入 import 模块都会被提前到文件顶部
* export 命令会有变量声明提前的效果，通过模块循环引用可以看出其效果

## 模块的循环依赖

> 循环依赖比较罕见，它也是一个重构代码重新设计的警示灯。

### CommonJS的循环依赖机制
参考：
* [node](https://nodejs.org/api/modules.html#modules_cycles)提供的例子
* [nodejs模块循环引用讲解](https://www.cnblogs.com/yourstars/p/9101468.html)


```js
// a.js
exports.done = false;
var b = require("./b.js");
console.log("在 a.js 之中，b.done = %j", b.done);
exports.done = true;
console.log("a.js 执行完毕");

// b.js
exports.done = false;
var a = require("./a.js");
console.log("在 b.js 之中，a.done = %j", a.done);
exports.done = true;
console.log("b.js 执行完毕");

// main.js
var a = require("./a.js");
var b = require("./b.js");
console.log("在 main.js 之中, a.done=%j, b.done=%j", a.done, b.done);
```

然后执行`main.js`进行测试，控制台依次输出

```js
在 b.js 之中，a.done = false
b.js 执行完毕
在 a.js 之中，b.done = true
a.js 执行完毕
在 main.js 之中, a.done=true, b.done=true
```

现在来解释一下这个输出
* 在main.js中首先加载a.js，然后直接执行a.js(**CommonJS模块的加载时运行特性**)
* a.js首先导出了`exports.done=false`，然后加载了b.js，此时会立即执行b.js（同上），等待b.js执行完成并将控制流程转交给a.js
* b.js首先导出了`exports.done = false`，然后加载了a.js，此时产生了循环依赖，由于a.js已经执行了一部分，这个时候并不是去重复执行a.js，而是读取a.js模块对象的exports属性，由于此时a.js并没有执行完，因此这个时候访问到的`done`属性仍为false
* 接着继续执行b.js，导出`exports.done=true`，当b.js结束后，控制权交还给a.js
* a.js继续执行，导出`exports.done=true`，然后将控制权转交给main.js
* main.js继续执行，需要加载b.js，由于b.js已经执行，此时并不会再次执行b.js，而是直接读取b.js模块的exports对象
* 由于a.js和b.js模块均已执行，此时输出`a.done`和`b.done`均为true

上面代码得出结论
* 在b.js之中，a.js没有执行完毕，只执行了第一行。
* main.js执行到第二行时，不会再次执行b.js，而是输出缓存的b.js的执行结果，即它的第四行

总结：

CommonJS 模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。一旦出现某个模块被"循环加载"，就只输出已经执行的部分，还未执行的部分不会输出。

由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。

```js
var a = require('a'); // 安全的写法
var foo = require('a').foo; // 危险的写法

exports.good = function (arg) {
  return a.foo('good', arg); // 使用的是 a.foo 的最新值
};

exports.bad = function (arg) {
  return foo('bad', arg); // 使用的是一个部分加载时的值，此时foo可能并不是最终导出的值
};
```

### AMD中的循环依赖
在requireJS中，如果a、b模块产生了循环依赖，那么在这种情况下当b的模块函数被调用时，将会提示模块a undefined。解决方法是b可以在模块已经定义好后用require()方法再获取，需要把require作为依赖注入进来。

即本来的写法是：
```js
// b.js
define(['a'],function (a) {
    return {
        test: function () {
            console.log(a.done) // a is undefined
        }
    }
});
```

requireJS推荐依赖前置，一般说来无需使用require()去获取一个模块，而是应当使用注入到模块函数参数中的依赖。
现在为了解决循环依赖带来的问题，首先要引入require的依赖，使用require()方法去获取模块a。

```js
// b.js
define(['require','a'],function (require,  a) {
    return {
        loading: function () {
            var a = require('a')
            console.log(a.done)
        }
    }
});
```