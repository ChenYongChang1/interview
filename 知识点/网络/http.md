HTTP
===
> GET 和 POST 有什么区别？


## 头部
### 常见的通用头
* __`Cache-Control`设置请求响应链上所有的缓存机制必须遵守的指令__
* `Date`用来说明构建报文的时间和日期

### 常见的请求头
Accept头部
* `Accept`设置接受的内容类型
* `Accept-Charset` 设置接受的字符编码
* `Accept-Encoding`设置接受的编码格式
* `Accept-Datetime`设置接受的版本时间
* `Accept-Language`设置接受的语言

请求实体首部行
* `Content-Type`设置请求体的MIME类型（适用POST和PUT请求）
* `Content-Length`设置请求体的字节长度
* `Content-MD5`设置基于MD5算法对请求体内容进行Base64二进制编码

资源请求头部
* `Origin`标识跨域资源请求（请求服务端设置Access-Control-Allow-Origin响应字段）
* `Range` 请求部分实体，设置请求实体的字节数范围，具体可以参见HTTP/1.1中的Byte serving

**条件请求头部**
* `if-Modified-Since` 设置更新时间，从更新时间到服务端接受请求这段时间内如果资源没有改变，允许服务端返回304 Not Modified
* `If-None-Match`设置客户端ETag，如果和服务端接受请求生成的ETage相同，允许服务端返回304 Not Modified
* `If-Match`设置客户端的ETag,当时客户端ETag和服务器生成的ETag一致才执行，适用于更新自从上次更新之后没有改变的资源
* `If-Range`设置客户端ETag，如果和服务端接受请求生成的ETage相同，返回缺失的实体部分；否则返回整个新的实体
* `If-Unmodified-Since` 设置更新时间，只有从更新时间到服务端接受请求这段时间内实体没有改变，服务端才会发送响应

**用户识别头部**
* `Cookie`设置服务器使用Set-Cookie发送的http cookie
* `Authorization`设置HTTP身份验证的凭证
* `From`设置发送请求的用户的email地址
* `Host`设置服务器域名和TCP端口号，如果使用的是服务请求标准端口号，端口号可以省略
* `Referer 设置前一个页面的地址，并且前一个页面中的连接指向当前请求，意思就是如果当前请求是在A页面中发送的，那么referer就是A页面的url地址`
* `User-Agent`用户代理的字符串值

### 常见的响应头
* `Set-Cookie`设置cookie

## 缓存
参考之前的[整理](http://www.shymean.com/article/HTTP%E5%8D%8F%E8%AE%AE%E4%B9%8B%E7%BC%93%E5%AD%98%EF%BC%88%E4%B8%89%EF%BC%89)

缓存的好处:
* 减轻了服务器的压力，服务器不必为来自同一个客户端的资源请求进行重复处理
* 提高了客户端的加载速度，从本地或者就近的缓存中读取资源，比从遥远的服务器获取资源要快得多

## HTTPS
参考
* [升级博客到HTTPS](https://www.shymean.com/article/%E5%8D%87%E7%BA%A7%E5%8D%9A%E5%AE%A2%E5%88%B0HTTPS),后面用伪代码整理了https的基本原理

HTTPS相对HTTP提供了更安全的数据传输保障。主要体现在三个方面：
* 内容加密。客户端到服务器的内容都是以加密形式传输，中间者无法直接查看明文内容。
* 身份认证。通过校验保证客户端访问的是自己的服务器。
* 数据完整性。防止内容被第三方冒充或者篡改。

其实为了提高安全性和效率HTTPS结合了对称和非对称两种加密方式。即客户端使用对称加密生成密钥（key）对传输数据进行加密，然后使用非对称加密的公钥再对key进行加密。

公钥就被包含在数字证书中。数字证书通常来说是由受信任的数字证书颁发机构CA，在验证服务器身份后颁发，证书中包含了一个密钥对（公钥和私钥）和所有者识别信息。数字证书被放到服务端，具有服务器身份验证和数据传输加密功能。

## HTTP2
参考
* [从理论到实践 全面理解HTTP/2](https://juejin.im/post/5c6a9f85e51d4503831ad4fa)

总结http2的特性
* Keep-alive: TCP持久连接，增加了TCP连接的复用性，但只有当上一个请求/响应完全完成后，client才能发送下一个请求
* Pipelining: 可同时发送多个请求，但是服务器必须严格按照请求的先后顺序返回响应，若第一个请求的响应迟迟不能返回
* 请求合并：雪碧图，css/js内联、css/js合并等，然而请求合并又会带来缓存失效、解析变慢、阻塞渲染、木桶效应等诸多问题
* 域名散列：绕过了同域名最多6个TCP的限制，但增加了DNS开销和TCP开销，也会大幅降低缓存的利用率


**二进制格式传输**

在HTTP/2中，新增了二进制分帧层，将数据转换成二进制，也就是说HTTP/2中所有的内容都是采用二进制传输

帧是HTTP/2中数据传输的最小单位；每个帧都有stream_ID字段，表示这个帧属于哪个流，接收方把stream_ID相同的所有帧组合到一起就是被传输的内容了。HTTP/2共定义了十种帧，较为常见的有数据帧、头部帧、PING帧、SETTING帧、优先级帧和PUSH_PROMISE帧等，为将来的高级应用打好了基础

在这种传输模式下，HTTP请求变得十分廉价，我们不需要再时刻顾虑网站的http请求数是否太多、TCP连接数是否太多、是否会产生阻塞等问题了。

**HPACK 首部压缩**
HTTP/1中，每个请求和响应都会携带对应的头部信息，每个页面的请求越多，越来越多的请求导致消耗在头部的流量越来越多，尤其是每次都要传输 UserAgent、Cookie 这类不会频繁变动的内容，完全是一种浪费

为了减少冗余的头部信息带来的消耗，HTTP/2采用HPACK 算法压缩请求和响应的header。其具体原理为
* 通信双方共同维护了一份静态表，包含了常见的头部名称与值的组合（比如method:GET，可以存在表中，然后只需要传递一个键名即可）
* 根据先入先出的原则，维护一份可动态添加内容的动态表
* 用基于该静态哈夫曼码表的哈夫曼编码数据

这样可以极大地节省头部的消耗

**server push**

HTTP/2的server push允许服务器在未收到请求时主动向浏览器推送资源。这样可以将资源提前推送到到浏览器：除了静态文件，还可以推送比较耗时的API

在HTTP1.1时代，也有提前获取资源的方法，如preload和prefetch，
* preload是在页面解析初期就告诉浏览器，这个资源是浏览器马上要用到的，可以立刻发送对资源的请求，当需要用到该资源时就可以直接用而不用等待请求和响应的返回了
* prefetch是当前页面用不到但下一页面可能会用到的资源，优先级较低，只有当浏览器空闲时才会请求prefetch标记的资源。

从应用层面上看，preload和server push并没有什么区别，但是server push减少浏览器请求的时间，略优于preload，在一些场景中，可以将两者结合使用。

