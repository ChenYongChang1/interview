JavaScript
===

## 基础知识
* 变量声明提前，变量作用域
* 闭包
* 作用域链与属性委托
* this
* call、apply、bind
* JS单线程，执行上下文、执行栈、异步
* ES6、7新特性
* 函数科里化

## 变量类型
变量类型包括
* 六种原始类型，包括Boolean、String、Number、Null、Undefined、Symbol
* 引用类型，Object对象

类型判断用到哪些方法
* typeof，可以得到undefined boolean number string object function、symbol等类型结果
* instanceof，用于实例和构造函数的对应

## 数据类型转换 == 和 ===
主要需要注意的是 == 操作符的比较规则，当两个数据的类型不一致时会发生类型转换，且可能同时发生类型转换，对应规则如下图所示
![](https://ws3.sinaimg.cn/large/006tNc79gy1fqaabatp6kj310i0aqgn8.jpg)

## null 和 undefined的区别
* null 表示一个对象是“没有值”的值，也就是值为“空”；
* undefined 表示一个变量声明了没有初始化(赋值)；

## 变量声明提升
在编译阶段，函数声明和变量声明都会提升到当前作用域的开头。每个作用域都会进行提升操作
* 函数声明会提升，但函数表达式不会
* 函数声明提升优先级大于变量声明提升，即函数声明提升会覆盖同名的变量声明提升

## 函数参数传递
要记住JS中的函数参数传递，都是按值进行的
* 原始类型的处理方式是，将参数的值完全复制一份，按值传递，
    * 对于传递过来的变量进行修改，不会影响到原变量。
* 引用类型的处理方式是，将参数的地址复制一份，按值传递地址(更准确的说是引用复制传递)
    * 对于变量的成员进行修改时，会直接影响原变量；
    * 而如果对传递过来的变量进行重新赋值，则不会影响原变量，并且此后再修改变量的成员，也不会影响原变量。
```
var obj = {
    x: 1
}
function foo(o){
    o.x = 100
}
function foo2(o) {
    o = 100
}

console.log(obj) // {x:1}

foo(obj)
console.log(obj) // {x:100}

foo2(obj)
console.log(obj) // // {x:100}
```

这种设计的意义在于：
* 按值传递的类型，复制一份存入栈内存，这类类型一般不占用太多内存，而且按值传递保证了其访问速度。
* 按共享传递的类型，是复制其引用，而不是整个复制其值（C 语言中的指针），保证过大的对象等不会因为不停复制内容而造成内存的浪费。

## 词法作用域
JavaScript采用的作用域规则是**词法作用域**。
词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写 代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）。

无论函数在哪里被调用，也无论它何时被调用，它的词法作用域都只由函数被声明时所处的位置决定。这对于理解闭包有很大的帮助。

在JavaScript中可以通过with和eval等方式欺骗词法，但是由于JavaScript引擎会在编译阶段对作用域查找进行性能优化，如果使用上述手段欺骗作用域，则可能导致程序运行效率的下降，因此不建议使用。

## 闭包
参考之前的[整理](http://www.shymean.com/article/%E5%86%8D%E6%8E%A2%E5%8E%9F%E5%9E%8B%E5%92%8C%E9%97%AD%E5%8C%85#2. %E9%97%AD%E5%8C%85)

当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。换句话说，闭包使得函数可以继续访问定义时的词法作用域。


闭包是在某个作用域内定义的函数，它可以访问这个作用域内的所有变量。闭包作用域链通常包括三个部分：
* 函数本身作用域。
* 闭包定义时的作用域。
* 全局作用域。

闭包函数对于其内部的变量查找遵循词法作用域的查找规则（即该闭包函数被声明时所处的位置决定），即使当闭包在其定义的词法作用域以外的地方执行时（比如闭包作为函数的返回值，或者闭包以函数参数的形式传入），这个查找规则也是生效的。

闭包常见用途：
* 创建特权方法用于访问控制，比如封装模块
* 事件处理程序及回调

## this


## 原型链
所有的对象都是由其构造函数创建，基础对象最基本的构造函数是Obecjt()。
* 每个对象都有一个" proto "的属性，指向该对象构造函数的原型，该属性也被称为隐式原型。
* 每个函数都有一个"prototype"的属性，表示这个构造函数的原型，函数的原型实际上是一个对象，并且该对象有一个construct的属性，指向构造函数本身。

当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会**委托**它的__proto__（即它的构造函数的prototype）中寻找，如果一直找到最上层都没有找到，那么就宣告失败，返回undefined。最上层是 `Object.prototype.__proto__ === null`

## 异步
> JS 是单线程运行的，即在同一时间只能做一件事。
参考之前的整理：[浏览器解析HTML的流程](http://www.shymean.com/article/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90HTML%E7%9A%84%E6%B5%81%E7%A8%8B)

前端异步的场景包括
* 网络请
* 事件处理函数
* 定时器，如setTimeout、setInverval

需要理解页面中整个JavaScript脚本从加载再到解析的整个流程。


-------

ES6
===

## let和const
`let`和`const`会声明的变量具有块级作用域，需要注意的是他们不会进行声明提升

## 箭头函数
箭头函数的好处
* 写起来更加简洁
* 可以将函数的this绑定到当前作用域，避免`var self = this`的情形

## Class
`class`关键字就是取代之前构造函数初始化对象的形式，从语法上更加符合面向对象的写法

需要注意的是
* 使用extends即可实现继承，更加符合经典面向对象语言的写法，如 Java
* 子类的constructor一定要执行super()，以调用父类的constructor

## 模块系统
参考之前的整理:[JavaScript模块管理机制](http://www.shymean.com/article/JavaScript%E6%A8%A1%E5%9D%97%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6)

### 一些常用的新特性
* let、const代替var，使用块级作用域
* 模板字符串，不需要手动去拼接字符串了
* 箭头函数，简化代码，自动绑定外部函数this
* 函数的默认参数，声明和展开剩余参数
* 解构赋值
* 对象字面量方法简写，动态属性名
* class关键字，创建类的语法糖

### ES6模块机制
新增`import`和`export`，参考
* [import文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import)
* [export文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/export)

export包括
* 命名导出，命名导出对导出多个值很有用。在导入期间，必须使用相应对象的相同名称。
* 默认导出，可以使用任何名称导入默认导出

注意不能使用var，let或const作为默认导出。

### CommonJS模块规范
使用`module.exports`、`exports`导出模块，使用`require`引入模块

CommonJS是同步加载的，也就是说加载模块时会阻塞后续代码的执行，这对于服务器端来讲问题不大，但是对于浏览器而言网络传输的效率是不容忽视的，所以才有了AMD规范

这里的一个问题是理解module.exports和exports的区别
* 整个文件导出的模块（也就是require() 的返回）是 module.exports
* module.exports和exports在初始时指向同一个对象，因此可以使用exports向模块对象上增加属性和方法
* module.exports如果指向了另外一个对象，则exports的修改全部无效了（因为最后导出的是module.exports）

另外一个问题是`require`加载包的顺序规则，在NodeJS内部有个很复杂实现，这里就不展开了，感兴趣可以移步这里：[require() 源码解读](http://www.ruanyifeng.com/blog/2015/05/require.html)

### AMD模块规范
通过`define`定义模块，通过`require`引入模块

由于浏览器在解析文档时，遇见脚本会加载解析和执行，为了提高页面性能，一般的处理办法是异步延迟加载，这正是AMD全称中Asynchronous的含义。

异步带来的问题是：在浏览器中，必须等待依赖的模块加载成功，对应的声明模块才能够执行。换句话说，AMD中的模块是依赖前置的。

## Promise
三个状态：pending、fulfilled、rejected

Promise核心思想是将所有的同步和异步代码都转换为异步执行，即先在then方法中注册对应的回调函数，然后才会执行对应的异步操作（同步代码也会转换成异步执行）

为了实现链式调用，每个then方法都会返回一个新的`Promise`对象，且在新的`Promise`的构造参数`resolver`中为前一个`promise`对象注册对应的回调函数，并根据对应对调的返回值`result`是否是可`thenable`的，
* 不是`thenable`，则直接执行该新的`Promise`对象的`resolve`
* 是`thenable`，则在返回值`result`的`then`方法中执行`resolve`

## 解构赋值
* 数组：按顺序赋值
* 对象：按属性名赋值

## Set 和 Map 数据结构
* ES6 提供了新的数据结构 Set 它类似于数组，但是成员的值都是唯一的，没有重复的值。
* ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。
