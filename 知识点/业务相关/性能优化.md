性能优化
===

参考：
* https://juejin.im/post/5a99f80cf265da238c3a1e16
* https://www.zhihu.com/question/21658448
* [腾讯新闻前端团队：深入理解前端性能监控](https://mp.weixin.qq.com/s/YI-96IbtIjTDzS-3N-9FAg)

前端性能优化可以从下面几个方面入手
* 减少请求数
    * 字体图标、雪碧图
    * 合并js、css
    * 长链接
    * 文件按需加载
* 优化请求速度
    * 预加载
    * 资源压缩，减少请求文件的体积
    * CDN
    * webp
* 缓存
    * http缓存
    * 本地数据持久化
* 首屏效果
    * ssr
    * 非关键资源延迟加载
    * 骨架屏

## 预加载

## 预先解析DNS
参考： 
* [MDN文档](https://developer.mozilla.org/zh-CN/docs/Controlling_DNS_prefetching)

> X-DNS-Prefetch-Control 头控制着浏览器的 DNS 预读取功能。 DNS 预读取是一项使浏览器主动去执行域名解析的功能，其范围包括文档的所有链接，无论是图片的，CSS 的，还是 JavaScript 等其他用户能够点击的 URL。因为预读取会在后台执行，所以 DNS 很可能在链接对应的东西出现之前就已经解析完毕。这能够减少用户点击链接时的延迟。

DNS查询也是需要消耗网络资源的，可以通过DNS预解析来优化页面的加载速度，预解析的实现：
* 用meta信息来告知浏览器, 当前页面要做DNS预解析:<meta http-equiv="x-dns-prefetch-control" content="on" />
* 在页面header中使用link标签来强制对DNS预解析: <link rel="dns-prefetch" href="http://bdimg.share.baidu.com" />

Chrome内置了DNS Prefetching技术, Firefox 3.5 也引入了这一特性，由于Chrome和Firefox 3.5本身对DNS预解析做了相应优化设置，所以设置DNS预解析的不良影响之一就是可能会降低Google Chrome浏览器及火狐Firefox 3.5浏览器的用户体验。

### preload
由于script标签加载同步脚本文件会阻塞文档的解析，可以通过link标签的preload标签预加载脚本文件，并将文件内容保存在内容中，但是不会执行，只有当
遇到script标签加载的也是preload相同的脚本资源时，才会执行预加载的脚本
```html
<!-- 预加载 -->
<link rel="preload" href="/index.js" as="script">
<!-- 遇见script标签时不会重新下载，而是执行前面preload的文件 -->
<script src="/index.js"></script>
```

### prefetch
在浏览器空闲的时候，现在对应资源，并缓存到磁盘上，当有页面使用该资源时，直接从磁盘缓存读取。
```html
<link href="/index.js" rel="prefetch">
```

需要注意的是，如果prefetch还没下载完之前，浏览器发现script标签也引用了同样的资源，就会重复再次发起请求，因此不要再马上需要使用资源的页面上使用prefetch，此时应该换用preload

### 浏览器最大请求域名限制
参考：
* [浏览器同域名请求的最大并发数限制](https://www.cnblogs.com/sunsky303/p/8862128.html)

浏览器对同一个服务器的并发连接个数都是有限制，如果请求的文件数量过多，浏览器的对于同一域名的并发数量限制就会成为一个影响加载性能的问题。

常见的处理方式是：**通过多个域名增加浏览器对同一网页的请求并发连接数**，一般来讲，静态资源都会使用单独的域名来进行加载，
* 可以绕开请求并发数量的限制
* 独立的域名不会携带Cookie等用户身份信息，减少了请求头的大小

## 减少http请求
http协议是无状态的应用层协议，意味着每次http请求都需要建立通信链路、进行数据传输，而在服务器端，每个http都需要启动独立的线程去处理。这些通信和服务的开销都很昂贵，减少http请求的数目可有效提高访问性能。

减少http的主要手段是合并CSS、合并JavaScript、合并图片。将浏览器一次访问需要的javascript和CSS合并成一个文件，这样浏览器就只需要一次请求。图片也可以合并，多张图片合并成一张，如果每张图片都有不同的超链接，可通过CSS偏移响应鼠标点击操作，构造不同的URL。

缓存的力量是强大的，恰当的缓存设置可以大大的减少 HTTP请求。假设某网站首页，当浏览器没有缓存的时候访问一共会发出 78个请求，共 600多 K数据，而当第二次访问即浏览器已缓存之后访问则仅有 10个请求，共 20多 K数据。 (这里需要说明的是，如果直接 F5刷新页面的话效果是不一样的，这种情况下请求数还是一样，不过被缓存资源的请求服务器是 304响应，只有 Header没有Body，可以节省带宽 )

怎样才算合理设置 ?原则很简单，能缓存越多越好，能缓存越久越好。例如，很少变化的图片资源可以直接通过 HTTP Header中的Expires设置一个很长的过期头 ;变化不频繁而又可能会变的资源可以使用 Last-Modifed来做请求验证。尽可能的让资源能够在缓存中待得更久。关于 HTTP缓存的具体设置和原理此处就不再详述了。

## 缓存
### 概述
对一个网站而言，CSS、javascript、logo、图标这些静态资源文件更新的频率都比较低，而这些文件又几乎是每次http请求都需要的，如果将这些文件缓存在浏览器中，可以极好的改善性能。通过设置http头中的cache-control和expires的属性，可设定浏览器缓存，缓存时间可以是数天，甚至是几个月。

在某些时候，静态资源文件变化需要及时应用到客户端浏览器，这种情况，可通过改变文件名实现，即更新javascript文件并不是更新javascript文件内容，而是生成一个新的JS文件并更新HTML文件中的引用。

使用浏览器缓存策略的网站在更新静态资源时，应采用逐量更新的方法，比如需要更新10个图标文件，不宜把10个文件一次全部更新，而是应该一个文件一个文件逐步更新，并有一定的间隔时间，以免用户浏览器忽然大量缓存失效，集中更新缓存，造成服务器负载骤增、网络堵塞的情况。

### 浏览器缓存
浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下：
* 先根据这个资源的一些 http header 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；
* 当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些request header验证这个资源是否命中协商缓存，称为http再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；

**强缓存**
* Expires（该字段是 http1.0 时的规范，值为一个绝对时间的 GMT 格式的时间字符串，代表缓存资源的过期时间）
* Cache-Control:max-age（该字段是 http1.1 的规范，强缓存利用其 max-age 值来判断缓存资源的最大生命周期，它的值单位为秒）

**协商缓存**
* Last-Modified（值为资源最后更新时间，随服务器response返回）
* If-Modified-Since（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）
* ETag（表示资源内容的唯一标识，随服务器response返回）
* If-None-Match（服务器通过比较请求头部的If-None-Match与当前资源的ETag是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）

强缓存和协商缓存
* 共同之处在于，如果命中缓存，服务器都不会返回资源；
* 区别是，强缓存不对发送请求到服务器，但协商缓存会。

当协商缓存也没命中时，服务器就会将资源发送回客户端。
* 当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；
* 当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存；

## 压缩文件
在服务器端对文件进行压缩，在浏览器端对文件解压缩，可有效减少通信传输的数据量。如果可以的话，尽可能的将外部的脚本、样式进行合并，多个合为一个。文本文件的压缩效率可达到80%以上，因此HTML、CSS、javascript文件启用GZip压缩可达到较好的效果。但是压缩对服务器和浏览器产生一定的压力，在通信带宽良好，而服务器资源不足的情况下要权衡考虑。

## 为什么利用多个域名来存储网络资源会更有效
参考
* https://blog.csdn.net/xujie_0311/article/details/42421027
* https://www.zhihu.com/question/20474326

其原因有以下几点：
1. 静态内容和动态内容分服务器存放，使用不同的服务器处理请求。处理动态内容的只处理动态内容，不处理别的，提高效率，这样使得CDN（内容分发网络）缓存更方便
2. 突破浏览器并发限制，浏览器同一时间可以从一个域名下载资源的数目有限制，这种技术被称为`domain hash`
3. 跨域请求不会携带cookie，可以节省带宽，这种技术被称为``cookie free`

附不同浏览器同一域名请求并发数目
![](https://ws1.sinaimg.cn/large/006tNc79gy1fqpt0g4402j315g0j276x.jpg)
图片来源：http://www.stevesouders.com/blog/2008/03/20/roundup-on-parallel-connections/

缺点是过多的域名分布会增加DNS解析的效率问题，或许可以通过DNS预解析处理这个问题

## 总结
* 减少http请求,主要思想就是减少HTML文档内链接的资源数量：
    * 项目上线时将`CSS``JavaScript`等文件压缩合并打包，减少源文件的数量和体积
    * 将多张小图片制作成精灵图
    * 将资源转换为`base64`编码
    * 使用缓存可以加快网页打开速度，有效减少http请求
    * 使用懒加载，按需加载对应资源
* 页面加载速度
    * 使用多个域名来存储网络资源
    * 页面渲染流程
        * 选择器从右向左解析，嵌套顺序不宜过深
    * 页面打开效率 
        * 使用CDN加载资源
        * 将CSS放在页面头部，防止页面闪烁
        * 将JavaScript异步或延迟加载，防止JavaScript运行阻塞页面加载
        * 延迟请求首屏外的文件，即优先加载首屏内容。
* 页面运行效率
    * reflow和repaint可能会严重影响性能，需要尽可能的减少reflow和repaint操作
        * 不要一条一条地修改DOM的样式，如果修改的样式过多可以将样式统一在某个类中，然后直接更改元素节点的className；
        * 使用临时变量保存DOM节点，而不是每次都直接对DOM节点进行操作（减少元素节点的读写），在JS性能与浏览器性能方面都能得到一些优化；
        * 尽可能修改层级比较低的DOM，缩小操作的影响范围；
        * 放弃使用table进行布局，一个很小的改动都会造成整个table的重新布局
    * JavaScript中减少作用域链的查找，避免使用`eval`和`Function`等性能缓慢的接口
    * DOM操作的代价是十分昂贵的，可以使用`DocumentFragment`暂时存放那些一次插入文档的节点
    * 事件节流


### 一些需要注意的小细节

问：**图片懒加载中，为何将实际图片资源路径放在`data-src`中?**
答：所有 HTML 中自定义的属性，都应该用data-开头，因为data-开头的属性浏览器渲染的时候会忽略掉，提高渲染性能。

