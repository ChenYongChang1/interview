## 基础

1.请解释盒子模型，以及如何告诉浏览器使用不同的盒子模型来渲染布局
答案：
盒子模型分为两类：W3C标准盒子模型和IE盒子模型 ：
* W3C盒子模型——属性高（height）和属性宽（width）这两个值不包含 填充（padding）和边框（border）
* IE盒子模型——属性高（height）和属性宽（width）这两个值包含 填充（padding）和边框（border）

使用`box-sizing`属性来告诉浏览器

2.列举你所知道的使用`css`实现垂直居中的方案
答案：
* 伸缩盒`display: flex;align-item:center`
* 绝对定位+外边距：`position: absolute;left: 0;right: 0;top: 0;bottom: 0; margin:auto 0;`
* 定位+ 负外边距
* 表格
* ...

3.请描述`Cookie`，`sessionStorage`，`localStorage`的区别

答案：

* cookies 和 Storage 的区别：
  * cookies会在服务器端和客户端间传递的；sessionStorage 和 localStorage存放在客户端的，不会发送至服务器端，仅在本地保存。
  * cookies的兼容主流浏览器,包括IE6+;IE6，IE7不支持sessionStorage 和 localStorage
    sessionStorage 和 localStorage中能存的数据比cookie大（cookie不能超过4k）

* sessionStorage 和 localStorage的区别：
  * sessionStorage存的数据在每次关闭浏览器后被删除，localStorage不会。
  * 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的

4.ajax请求中get和post方法的区别（缺点）

答案：

GET方法

* 由于地址相同，浏览器会缓存导致忽略第二次及后面的动态数据，解决这个问题可以加上一个时间戳&t=或者随机数

* 将参数拼接到URL后，中文可能乱码，解决办法是将中文进行编码传输，[js对字符串进行编码方法总结](http://www.cnblogs.com/Miton/archive/2011/07/25/2116292.html)

* URL的长度是有限制的，过长的话浏览器会报414错误

POST方法：
* 无法使用缓存文件（更新服务器上的文件或数据库）
* POST 没有数据量限制，可以向服务器发送大量数据
* 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠

5.常用的web性能优化方案

* http请求，减少http请求的主要主要思想就是减少HTML文档内链接的资源数量：
  * 项目上线时将`CSS``JavaScript`等文件压缩合并打包，减少源文件的数量和体积
  * 将多张小图片制作成精灵图
  * 将资源转换为`base64`编码
  * 使用缓存可以加快网页打开速度，有效减少http请求
  * 使用懒加载，按需加载对应资源

* 页面打开速度
  * 使用CDN加载资源
  * 将CSS放在页面头部，防止页面闪烁
  * 将JavaScript异步或延迟加载，防止JavaScript运行阻塞页面加载
  * 延迟请求首屏外的文件，即优先加载首屏内容。

*执行效率
  * 选择器从右向左解析，嵌套顺序不宜过深
  * JavaScript中减少作用域链的查找，避免使用`eval`和`Function`等性能缓慢的接口
  * DOM操作的代价是十分昂贵的，可以使用`DocumentFragment`暂时存放那些一次插入文档的节点

6.什么是跨域限制？解决方案有哪些
由于浏览器的同源策略，`Javascript`只能操作与其加载文档同源的其他文档内容，同源指的是：协议相同，域名相同，端口号相同。
解决办法由：
* 修改`domain`，避开域名不同的限制
* CORS，服务器配置跨域资源共享
* JSONP，通过`script`标签的`src`属性发送get请求
* 服务器中转请求


## 代码阅读
注意：注释是答案，记得移除

题目1.
```javascript
  var obj1 = {
      name: "obj1",
      fn(){
          console.log(this.name);
      }
  };
  var obj2 = { name: "obj2" };
  var obj3 = { name: "obj3" };
  obj1.fn(); // obj1
  var newFn = obj1.fn;
  newFn(); // "" 注意这里不是undefined
  newFn.call(obj2); // obj2
  obj3.fn = newFn;
  obj3.fn(); // obj3

  var newFn = obj1.fn.bind(obj1);
  newFn(); // obj1
  newFn.call(obj2); // obj1，注意这个地方是强绑定，所以一直为obj1
  obj3.fn = newFn;
  obj3.fn(); // obj1 ，同上
```

题目2.
```javascript
	var a = 100;
    var fn = () => {
        console.log(a);
        var a = 200;
        console.log(a);
    }
    fn(); // undefined, 200
    console.log(a); // 100
    var a;
    console.log(a); // 100
    var a = 300;
    console.log(a); // 300
```

题目3.
注意：这道题的难度比较大
```javascript
function Foo() {
    getName = function() {
    alert(1);
};
	return this;
}
Foo.getName = function() {
	alert(2);
};
Foo.prototype.getName = function() {
    alert(3);
};
var getName = function() {
	alert(4);
};

function getName() {
	alert(5);
}

//请写出以下输出结果：
Foo.getName(); // 2
getName(); // 4
Foo().getName(); // 1
getName(); // 1
new (Foo.getName)(); // 2
new Foo().getName(); // 3
new ((new Foo()).getName)(); // 3
```


## 函数实现
注意：代码块是答案，记得移除

题目1:实现字符串反转
```javascript
var reverse = function(str){
	return str.split("").reverse().join("");
}
```

题目2:找出数组中的最大值
```javascript
var findMax = function(arr){
	return Math.max.apply(null, arr);
}
```

题目3:实现冒泡排序或者快速排序

```javascript
// 冒泡排序
let bubbleSort = function (arr) {
      for (let i = 0, len = arr.length;i < len; ++i){
          for (let j = 0; j < len - i; ++j){
              if (arr[j] > arr[j+1]){
                  swap(arr, j, j + 1);
              }
          }
      }
      return arr;
};

//快速排序
let quickSort = function (arr) {

    let sort = function (left, right) {
        if (left  > right){
            return ;
        }

        let key = arr[left];

        let i = left,
            j = right;
        while(i !== j){
            while(arr[j] >= key && i < j){
                j--;
            }
            while(arr[i] <= key && i < j){
                i++;
            }
            if (i < j){
                swap(arr, i, j);
            }
        }
        arr[left] = arr[i];
        arr[i] = key;

        sort(left, i-1);
        sort(i+1, right);
    };
    sort(0, arr.length - 1);

    return arr;
};
```