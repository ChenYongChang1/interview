## 面试题1

### HTTP状态码及其含义
* 1
* 2 成功
* 3 重定向
* 4 客户端错误
* 5 服务端错误

### 设置元素浮动后，该元素的display属性
都为`block`

### 请描述`Cookie`，`sessionStorage`，`localStorage`的区别
相同：
都是保存在浏览器，且同源的。

区别：
* cookies 和 Storage 的区别：
  * cookies会在服务器端和客户端间传递的；sessionStorage 和 localStorage存放在客户端的，不会发送至服务器端，仅在本地保存。
  * cookies的兼容主流浏览器,包括IE6+;IE6，IE7不支持sessionStorage 和 localStorage
    sessionStorage 和 localStorage中能存的数据比cookie大（cookie不能超过4k）

* sessionStorage 和 localStorage的区别：
  * sessionStorage存的数据在每次关闭浏览器后被删除，localStorage不会。
  * 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的

### 请解释盒子模型，以及如何告诉浏览器使用不同的盒子模型来渲染布局
盒子模型分为两类：W3C标准盒子模型和IE盒子模型 ：
* W3C盒子模型——属性高（height）和属性宽（width）这两个值不包含 填充（padding）和边框（border）
* IE盒子模型——属性高（height）和属性宽（width）这两个值包含 填充（padding）和边框（border）

使用`box-sizing`属性来告诉浏览器



### ajax请求中get和post的区别
* 使用Get请求时,参数在URL中显示,而使用Post方式,则不会显示出来
* 使用Get请求发送数据量小,Post请求发送数据量大

### 下面代码输出
```
var foo = {n: 1}
var bar = foo;
foo.x = foo = {n:2};

foo.x; // undefined
```
主要是由于虽然赋值运算符具有右结合性，然而它首先做的是得到表达式foo.x的值，因此后执行foo = {n:2}导致foo被重写，打印bar.x可以得到预期结果

### 页面在哪些浏览器内核中测试过
目前主流的四大浏览器内核
* Trident，对应IE
* Gecko，对应firefox
* WebKit，对应chrome,safiri
* Presto，对应Opera前内核

### 下面代码输出
```
window.a = 1;
var json = {
  a: 10,
  db: function(){
    this.a *= 2;
  }
}

json.db();
var db = json.db;
db();
json.db.call(window);

alert(window.a + json.a); // 24
```
简单考察了一下this的指向

### 下面代码输出
```javascript
function func1(){
	var n = 99;

    nAdd = function(){
        this.n += 1;
        console.log(this.n);
    }

    function func2(){
        console.log(n);
    }

    return func2;
}

var res = func1();

res(); // 99
nAdd(); // NAN
res(); // 99
```

### 下面代码输出
```
var obj = {
    name: "obj",
    dose: function(){
        this.name = "dose";
        return function(){
        	return this.name;
        }
    }
}

	console.log(obj.dose().call(this));  // 注意是""而不是undefined，这是因为window对象本身就有一个name属性...
```

### 实现函数
```
var docs = [
	{id:1, words: ["hello", "world"]},
	{id:2, words: ["hello", "kids"]},
	{id:3, words: ["hello", "hello"]},
];
	
var res = finDocList(docs, ["hello"]); // 1,2,3
var res = finDocList(docs, ["hello", "world"]); // 1
```

实现
```
var finDocList = function(docs, target){
	var res = docs.filter((item)=>{
        var words = item.words;
        for (var i = 0, len = target.length; i < len; ++i){
            var idx = words.indexOf(target[i])
            if (!~idx){
                return false;
            }
        }
        return true;
	})
	return res;
};
```

### 实现深度克隆函数
```
var deepClone = function(target, obj){
    for (var key in obj){
        if (obj.hasOwnProperty(key)){
            var val = obj[key];
            if (typeof val === "object") {
                target[key] = {};
                deepClone(target[key], val)
            }else {
                target[key] = val;
            }
        }
    }
    return target;
}
```

### 敏感词标记
```
var content = "XX阿斯顿撒旦撒旦和轻微oo饥饿和武as器就可怜见看完你去了哇";
var res = content.replace(/(XX|oo|as)/g, "<span>$1</span");
console.log(res);
```

### 实现快排
```
var arr = [100,2,33,79,54,32,89];

		var quickSort = function(left, right){
			if (left  > right){
	            return ;
	        }

			var key = arr[left],
				i = left,
				j = right;

			while(i != j){
				while(arr[i] <= key && i != j){
					i++;
				}
				while(arr[j] >= key && i != j){
					j--;
				}
				if (i < j){
					var tmp = arr[i];
					arr[i] = arr[j];
					arr[j] = tmp;
				}
				
			}
			arr[left] = arr[i];
			arr[i] = key;
			
			quickSort(left, i - 1);
			quickSort(i + 1, right);
		}

		quickSort( 0, arr.length - 1);
		console.log(arr);
```

### 事件委托
一个定时器，定时向容器插入`a`标签，要求任何时刻点击`a`标签都弹出对应数据，复习事件委托
```
t.onclick = function(e){
    var target = e.target
    if (target.tagName.toUpperCase() == "A"){
    	alert(target.innerHTML);
    }
}
```
### 代码输出
```
var k = c = 5;
function a(n){
    return n ? (n-1)*a(n-1): n;
    k++;
    c++;
    if(c > 10) return c;
}

var res = a(5);
console.log(k, c, res); // 5, 5, 0 这个题简直太渣了
```

### 实现字符串反转
```
var reverse = function(str){
	return str.split("").reverse().join("");
}
```

### 如何修改chorme记住密码后的黄色背景
这是由于`input:-webkit-autofill `引起的

### 数组随机排序
```
arr.srot(()=>{
  	return Math.random() > 0.5 ? 1 : -1;
})
```
### 移动开发中meta基础知识点
* 页面窗口自动调整到设备宽度，并禁止用户及缩放页面。
* 忽略将页面中的数字识别为电话号码
* 忽略Android平台中对邮箱地址的识别
* 当网站添加到主屏幕快速启动方式，可隐藏地址栏，仅针对iOS的safari
* 将网站添加到主屏幕快速启动方式，仅针对ios的safari顶端状态条的样式
* 需要在网站的根目录下存放favicon图标，防止404请求(使用fiddler可以监听到)

### 如何检测变量是否为数组
使用`instanceof Array`

### 取出数组中的最大值
不使用遍历
```
var res = Math.max.apply(null, arr);
```

### call和apply的相似和区别
* 都是改变函数内部的this指向
* call后面的参数均表示函数的单个参数，apply的第二个参数用数组包含函数的多个参数