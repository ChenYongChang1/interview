
## 作用域的规则
JS的函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用
包含变量和函数在内的所有声明都会在任何代码执行前首先被处理。
* 函数声明会提升，但函数表达式不会
* 函数声明提升优先级大于变量声明提升    


## 描述一下作用域链
JS里面的函数作用域和块级作用域都可以进行嵌套，当对变量进行**右查询**时，如果在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域继续查找，直到找到该变量或者抵达全局作用域为止，否则会抛出**ReferenceError错误**。这种一层一层查找变量的方式就是作用域链
扩展：
* 左查询与右查询

## 谈谈你对于闭包的理解
JS里面的作用域是**词法作用域**，因此无论函数在哪里被调用，也无论它何时被调用，它的词法作用域都只由函数被声明时所处的位置决定。
对于不在函数内部声明却在函数内部使用的**自由变量**，同样遵循词法作用域的限制。当函数在其声明的词法作用域之外执行，仍旧可以访问函数声明时的词法作用域，此时就产生了闭包。

扩展：
* 常见的闭包陷阱，如循环中的闭包
* 闭包的使用，如封装模块

## this的指向
虽然JS采用的是词法作用域，但this并不是在编写时绑定的，而是是在函数运行时自动绑定到函数作用域的，它的上下文取决于函数调用时的各种条件。
* 函数是否在 new 中调用？如果是的话 this 绑定的是新创建的对象。 
* 函数是否通过 call、apply（显式绑定）或者 bind 硬绑定调用？如果是的话，this 绑定的是 指定的对象。
* 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。
* 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到 全局对象。

扩展：
* 箭头函数


## 跨域以及常见的解决方案
同源策略：JavaScript脚本只能读取和所属文档来源相同的窗口和文档的属性。
浏览器处于安全性的考虑，对JavsScript做了同源限制，但是在某些时候，这些限制却过于严格了，在项目中常用的跨域措施有
* 多个子域名之间的跨域,修改`document.domain`
* CORS跨域资源共享标准，服务器返回`Access-Control-Allow-Origin`
* JSONP，script标签的src属性不受同源限制
* 服务器代理
* postMessage

扩展：
* 跨域请求多出的一次 OPTIONS 请求
* `Access-Control-Allow`其他头部
* JSONP的实现与不足

## 常见的Web安全问题
XSS是跨站脚本攻击，指的是在用户浏览器渲染整个HTML文档过程中出现了不被预期的脚本指令。常见的处理措施有
* 过滤用户的输入，对输出到页面的文档进行转义，可有效防止反射XSS和存储XSS
* 要尽力避免代码中比较常规的一些安全漏洞，比如eval等。

* 输入校验，包括长度限制、值类型是否正确，是否包含特殊字符
* 输出编码，根据输出位置进行相应的编码，遵守该数据不要超出自己所在的区域，也不要被当作指令执行

CSRF是跨站请求伪造，攻击的发生是由各种请求造成的，对于CSRF来说，它的请求有两个关键点，跨站点和请求伪造。诱导用户访问恶意网站，并构造一个正常请求，由于正常请求会携带用户身份信息，就可以发生攻击了。常见的处理措施有
* 检验referrer
* 使用随机生成的一次性token，然后对提交的请求进行校验

扩展：
* 在项目中有没有遇到什么安全漏洞的问题

## 描述输入URL到浏览器接收到HTML文档
* 浏览器需要解析URL，获取域名
* 委托操作系统进行DNS查询，获取域名对应的IP地址
* 操作系统协议栈构造套接字，建立套接字需要进行三次握手，断开连接需要进行四次挥手
* TCP/IP包包含IP地址（寻找目标主机）和MAC地址（通过广播寻找下一个通向目标主机的中转设备），在网络传输中，包中的IP地址是不变的，但是MAC是会发生变化的。
* 在调制解调器器中对信号进行转换，数字信号 <-> 光、电信
* 服务器包含两个模块：等待连接模块和负责与客户端通信的模块，当新客户端发起请求时，就创建一个新的套接字
* 服务器根据URL，直接返回静态资源；或者调用对应的CGI程序，解析URL，调用对应的控制器方法，进行逻辑处理，最后生成填充数据后的模板，返回HTML文档
* 响应的HTML文档经过网络传输，如果数据量较大，将会被拆分成多个数据包，然后通过窗口号进行管理，最后还原数据
* HTML文档最终被浏览器接收并解析，然后进行渲染

## 描述浏览器解析HTML文档的过程
这里主要是理解CSS 与 JS 是如何阻塞 DOM 解析和渲染的。
当浏览器从上到下解析整个HTML文档时，
* 如果遇见内联的样式表，就会立即解析（但不一定会立即渲染出样式）；如果遇见内联的脚本，就会立即解析和执行；
* 如果遇见外部URL资源，就会发送请求加载对应文件，如果是普通的script，则会等待脚本加载完成后解析和执行JS代码，然后在继续HTML的解析。
* CSS无法解析DOM的解析，但会阻止页面的渲染，样式表会阻塞JS的解析和执行，这是因为脚本内部可能依赖于最新的计算属性
* JS会阻塞DOM的解析，这是因为JS可以操作DOM(比如document.write等丧心病狂的功能)，因此浏览器需要等待JS执行完成
* 遇见带async的script标签，浏览器会继续下载解析并执行JS，但此时的script不会阻塞浏览器解析HTML文档
* 遇见带defer的script标签，浏览器会继续下载，但此时的script不会阻塞浏览器解析HTML文档，直到HTML解析完成后才开始执行脚本内容

## 描述浏览器渲染HTML文档的过程
首先浏览器会分别解析下面HTML（生成DOM树）和CSS（生成CSS规则树），然后根据DOM树和CSS规则树来生成渲染树，最后调用系统的渲染API进行绘制。
这里需要注意Reflow和Repaint的区别。

## 在项目中是如何性能优化的
主要从下面三个方面回答
* 减少HTTP请求
    * 精灵图，合并多个CSS、JS文件，减少文件的数量和体积
    * 图片压缩（从PSD切的图一般体积比较大）、base64转换
    * 图片懒加载，按需加载
    * 使用缓存
* 页面渲染速度
    * 使用CDN加载资源
    * 将CSS放在页面头部，防止页面闪烁
    * 将JavaScript异步或延迟加载，防止script标签阻塞页面加载
    * 延迟请求首屏外的文件，优先加载首屏内容。
* 代码执行效率
    * reflow和repaint可能会严重影响性能，需要尽可能的减少reflow和repaint操作
    * JavaScript中减少作用域链的查找，避免使用`eval`和`Function`等性能缓慢的接口
    * DOM操作的代价是十分昂贵的，可以使用`DocumentFragment`暂时存放那些一次插入文档的节点
    * 事件节流、除抖

## 谈谈对于MVVM框架的理解
把系统分为三个基本部分：模型（Model）、视图（View）和视图模型（ViewModel）。
ViewModel大致上就是MVP的Presenter和MVC的Controller了，而View和ViewModel间没有了MVP的界面接口，而是直接交互，用数据“绑定”的形式让数据更新的事件不需要开发人员手动去编写特殊用例，而是自动地双向同步。
数据绑定你可以认为是Observer模式或者是Publish/Subscribe模式，原理都是为了用一种统一的集中的方式实现频繁需要被实现的数据更新问题。
比起MVP，MVVM不仅简化了业务与界面的依赖关系，还优化了数据频繁更新的解决方案，甚至可以说提供了一种有效的解决模式。

## new Vue(options)中发生了什么操作
* 初始化，调用this._init进行初始化，
    * 包括生命周期、事件、 props、 methods、 data、 computed 与 watch 等，
    * 此外最重要的是通过Object.defineProperty设置data参数属性setter与getter函数，用来用来实现响应式数据以及依赖收集
* 模板编译，如果传入的是template而不是render函数，则会进行模板编译过程。
    * parse，通过正则解析模板，生成AST
    * optimize，优化AST，包括标记静态节点，为后续path操作提供优化基础
    * generate，将AST转换成渲染函数
* 渲染页面，调用渲染函数，根据Vnode生成DOM节点，然后挂载到页面上
* 在这个过程中会调用对应的生命周期钩子函数
* 更新页面，当data发生变化时，依赖收集执行的Dep会通知相关watcher，更新视图，通过diff算法按需更新Vnode，重新渲染相关节点，更新页面

## Vue响应式系统的原理
在渲染函数执行时，因为会读取所需对象的值，所以会触发 getter 函数进行依赖收集。 依赖收集的实质是是将观察者 Watcher 对象存放（pushTarget(this)修改Dep._target) 到当前闭包中的订阅者 Dep 的 subs。一个属性可能对应多个Watcher，他们都保存在该属性对应的Dep中。

修改对象的值的时候，会触发对应的setter， 在setter内部通知之前依赖收集到的Dep中的每一个Watcher，这些 Watcher 就会开始调用update来更新视图，从而重新渲染视图。

具体过程为
* vue将data初始化为一个Observer并对对象中的每个值，重写了其中的get、set，data中的每个key，都有一个独立的依赖收集器。
* 在get中（模板渲染或其他使用到该属性值的地方），向依赖收集器添加了监听
* 在mount时，实例了一个Wathcer，将收集器的目标指向了当前Watcher
* 在data值发生变更时，触发set，触发了依赖收集器中的所有监听的更新，来触发Watcher.update

## 谈谈你对于缓存的了解程度
Web缓存对于性能优化十分重要，可以有效减少HTTP请求。
Web缓存是指一个Web资源（如html页面，图片，js，数据等）存在于Web服务器和客户端（浏览器）之间的副本。下一个请求如果是相同的URL，则会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求

扩展：
* `Cache-Control: max-age`和`Expries`的区别，前者指定资源的新鲜度秒数，后者指定资源的过期时间，由于服务器时区并不一定同步，因此后者优先级不如前者

## 说一说CDN的工作原理
当业务需要接入到 CDN 时，用户只需调整自己的 DNS 配置信息，将IP记录改为 CNAME 记录，将内容改为 CDN 厂商所提供的接入域名即可。
浏览器解析CDN域名，得到的是CNAME记录，再次对CNAME进行解析，得到CDN服务器的地址，接着访问对应的缓存服务器，缓存服务器会根据浏览器提供的域名，访问实际的数据服务器，获得响应后，一方面向浏览器返回数据，一方面缓存数据（后续访问在缓存失效前可直接返回数据）。

## HTTPS你了解吗
由于http使用明文发送报文，因此容易发生中间人攻击，为了防止信息在网络传输过程中被修改，因此需要被通信内容进行加密，加密有两种方式：共享密钥加密和公开密钥加密。

为了防止共享密钥加密的密钥被窃取，同时为了避免公开密钥加密导致的效率问题，因此一般的处理方式是使用公开密钥加密传输共享密钥加密的密钥，然后使用共享密钥加密对通信内容进行加密。

为了保证上述过程中公开密钥的合法性，需要通过数字证书，由服务器运营人员申请，向第三方权威机构来进行认证。

## 简单TCP三次握手和四次挥手的过程
三次握手：
* 客户端–发送带有SYN标志的数据包–一次握手–服务端
* 服务端–发送带有SYN/ACK标志的数据包–二次握手–客户端
* 客户端–发送带有带有ACK标志的数据包–三次握手–服务端

四次挥手：
* 客户端-发送一个FIN，用来关闭客户端到服务器的数据传送
* 服务器-收到这个FIN，它发回一个ACK，确认序号为收到的序号加1 。和SYN一样，一个FIN将占用一个序号
* 服务器-关闭与客户端的连接，发送一个FIN给客户端
* 客户端-发回ACK报文确认，并将确认序号设置为收到序号加1