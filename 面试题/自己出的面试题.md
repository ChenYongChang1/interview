
## 作用域的规则
JS的函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用
包含变量和函数在内的所有声明都会在任何代码执行前首先被处理。
* 函数声明会提升，但函数表达式不会
* 函数声明提升优先级大于变量声明提升    


## 描述一下作用域链
JS里面的函数作用域和块级作用域都可以进行嵌套，当对变量进行**右查询**时，如果在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域继续查找，直到找到该变量或者抵达全局作用域为止，否则会抛出**ReferenceError错误**。这种一层一层查找变量的方式就是作用域链
扩展：
* 左查询与右查询

## 谈谈你对于闭包的理解
JS里面的作用域是**词法作用域**，因此无论函数在哪里被调用，也无论它何时被调用，它的词法作用域都只由函数被声明时所处的位置决定。
对于不在函数内部声明却在函数内部使用的**自由变量**，同样遵循词法作用域的限制。当函数在其声明的词法作用域之外执行，仍旧可以访问函数声明时的词法作用域，此时就产生了闭包。

扩展：
* 常见的闭包陷阱，如循环中的闭包
* 闭包的使用，如封装模块

## this的指向
虽然JS采用的是词法作用域，但this并不是在编写时绑定的，而是是在函数运行时自动绑定到函数作用域的，它的上下文取决于函数调用时的各种条件。
* 函数是否在 new 中调用？如果是的话 this 绑定的是新创建的对象。 
* 函数是否通过 call、apply（显式绑定）或者 bind 硬绑定调用？如果是的话，this 绑定的是 指定的对象。
* 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。
* 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到 全局对象。

扩展：
* 箭头函数


## 跨域以及常见的解决方案
同源策略：JavaScript脚本只能读取和所属文档来源相同的窗口和文档的属性。
浏览器处于安全性的考虑，对JavsScript做了同源限制，但是在某些时候，这些限制却过于严格了，在项目中常用的跨域措施有
* 多个子域名之间的跨域,修改`document.domain`
* CORS跨域资源共享标准，服务器返回`Access-Control-Allow-Origin`
* JSONP，script标签的src属性不受同源限制
* 服务器代理
* postMessage

扩展：
* 跨域请求多出的一次 OPTIONS 请求
* `Access-Control-Allow`其他头部
* JSONP的实现与不足

## 常见的Web安全问题
XSS是跨站脚本攻击，指的是在用户浏览器渲染整个HTML文档过程中出现了不被预期的脚本指令。常见的处理措施有
* 过滤用户的输入，对输出到页面的文档进行转义，可有效防止反射XSS和存储XSS
* 要尽力避免代码中比较常规的一些安全漏洞，比如eval等。

* 输入校验，包括长度限制、值类型是否正确，是否包含特殊字符
* 输出编码，根据输出位置进行相应的编码，遵守该数据不要超出自己所在的区域，也不要被当作指令执行

CSRF是跨站请求伪造，攻击的发生是由各种请求造成的，对于CSRF来说，它的请求有两个关键点，跨站点和请求伪造。诱导用户访问恶意网站，并构造一个正常请求，由于正常请求会携带用户身份信息，就可以发生攻击了。常见的处理措施有
* 检验referrer
* 使用随机生成的一次性token，然后对提交的请求进行校验

扩展：
* 在项目中有没有遇到什么安全漏洞的问题

## 描述输入URL到浏览器接收到HTML文档
* 浏览器需要解析URL，获取域名
* 委托操作系统进行DNS查询，获取域名对应的IP地址
* 操作系统协议栈构造套接字，建立套接字需要进行三次握手

## 描述浏览器渲染HTML文档的过程
首先浏览器会分别解析下面HTML（生成DOM树）和CSS（生成CSS规则树），然后根据DOM树和CSS规则树来生成渲染树，最后调用系统的渲染API进行绘制。
这里需要注意Reflow和Repaint的区别。


## 描述浏览器中JavaScript的同步和异步

## HTTP缓存


## 谈谈对于MVVM框架的理解
把系统分为三个基本部分：模型（Model）、视图（View）和视图模型（ViewModel）。
ViewModel大致上就是MVP的Presenter和MVC的Controller了，而View和ViewModel间没有了MVP的界面接口，而是直接交互，用数据“绑定”的形式让数据更新的事件不需要开发人员手动去编写特殊用例，而是自动地双向同步。数据绑定你可以认为是Observer模式或者是Publish/Subscribe模式，原理都是为了用一种统一的集中的方式实现频繁需要被实现的数据更新问题。比起MVP，MVVM不仅简化了业务与界面的依赖关系，还优化了数据频繁更新的解决方案，甚至可以说提供了一种有效的解决模式。